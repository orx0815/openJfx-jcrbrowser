# OpenJfx Jcr Browser

###Proof-of-concept maven build for java desktop-applications

This javaFX application itself is useless, it's just a PoC around the tooling - Rapid-Application-Development robot gui testing, springboot and deployment.

This maven setup  generates a variety of deployment artefacts. It produces:

- Old-school exceutable jars with dependencies included. Needs jvm installed.
- Platform dependent installers with custom modularized jvm. On Windows .msi, on Mac .dmg or .pks, on Linux .deb or .rpm files.
- Ahead-of-Time compiled native binaries generated by [GraalVm](https://www.graalvm.org/) using the [Gluon Client plugin](https://github.com/gluonhq/client-maven-plugin). No jvm needed anymore. 
- JNLP generation and jar-signing for web-based installations from static webserver with [OpenWebStart](https://openwebstart.com/). Unlike java-8 [Oracle WebStart](https://en.wikipedia.org/wiki/Java_Web_Start), it has a jvm manager.
- Web server to run it in the browser after all. This is a product from [jPro](https://www.jpro.one) and NOT free for commercial use. And not open-source. But quite impressive, you can try it out without any hassle by just adding their maven plugin.
 
 All from the same codebase.
 
### Used frameworks, libraries 
- Obviously [OpenJfx](https://openjfx.io/). JavaFX, but now open source.
- Visual Rapid-Application-Development with [Scene Builder](https://gluonhq.com/products/scene-builder/), a WYSIWYG editor to generate [FXML](https://docs.oracle.com/javase/8/javafx/api/javafx/fxml/doc-files/introduction_to_fxml.html) from.
- FXML includes for separation of java controllers. Without it, the main controller develops quickly into a god-class. This in turn leads to the need for some Dependency-Injecton, as it's otherwise quite cumbersome to pass around those controller-instances so they can reach each other.
- Springboot. This is a bit like 'taking a sledgehammer to crack a nut' to solve the above. There are more lightweight DI frameworks able do this, google-guice or [afterburner.fx](https://github.com/AdamBien/afterburner.fx). 
On the other hand it comes with some useful things like easy jar generation, lots of developers have experience with it and can be thrown at it to take care about business logic and to provide beans to be used inside javaFX controllers.

- junit5, robot api for gui and integration tests, sling jcr-mock
  
 
 
### The Jcr browser application itself

Think of [JCR](https://dzone.com/articles/java-content-repository-best) as an example for ANY 3rd party java dependency, that's not JPMS / Jigsaw modularized.

I started playing with this when javaFX was still part of the oracle jvm. The idea was to use a JcrNode as data-model for a TreeView and then do some CRUD operations on the content.
There is no need for a Java-Content-Repository to run the application, it will show an 'DisplayShelf' from some old Netbeans example projects just to show that javaFX is more then boring backoffice applications. (Even though this is basically the usecase here) 

If you want to connect to a Jcr and don't have an 'Adobe Experience Manager' at hand you can download the [sling-starter-standalone.jar](https://sling.apache.org/downloads.cgi#sling-application), run the jar with java11 and press the Login button in the browser application with the prefilled values.

 It uses a servlet from sling-jcr-davex bundle to access remote repository the same way crx.de does in AEM.
 
***

## Build and run

#### Requirements

java11+ 
maven 3.6.x

Make sure `JAVA_HOME` is properly set to the Java installation directory.


**Build the project**

    mvn install
    

**Run the project**
    
    mvn exec:java


or from spring-boot-maven-plugin:
     
    mvn spring-boot:run
    
    
or with the [javafx-maven-plugin](https://github.com/openjfx/javafx-maven-plugin)

    mvn javafx:run
 
Note that 'mvn javafx:jlink' won't work, as the application is not modularized due to non-modular dependencues.

**Debug** (and prevent screen-grab from ide) [1]

    mvn exec:exec -Dexec.executable=$JAVA_HOME"/bin/java" -Dexec.args="-classpath %classpath -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=1044 -Dglass.disableGrab=true org.motorbrot.javafxjcrbrowser.Main"
   
***

## Distribute

Ways to produce installable artifacts. 


    
#### Build a distributable uber/fat.jar and run it:

    mvn package
Builds two jars, to be stated with `java -jar`

The uber.jar is build by maven-shade-plugin, the fat.jar by [spring-boot-maven-plugin](https://docs.spring.io/spring-boot/docs/current/reference/html/executable-jar.html). (The latter has less but colored console output.)

    java -jar ./target/openjfx-jcr-browser-0.0.1-SNAPSHOT-uber.jar
    java -jar ./target/openjfx-jcr-browser-0.0.1-SNAPSHOT-fat.jar

This is the 'old' style and still requires java to be installed on the target system. This is normally too much for normal users so the modern way is "bring your own jvm":

####  Build platform dependent installers including custom small jvm
Requires java14+ as the [jpackage](https://openjdk.java.net/jeps/392) tool is only available there.
In java16 it moves from incubator state to a production-ready feature.

Since the application is not modularized due to non-modular 3rd party dependencies, some extra steps are performed here. This is inspired by Dirk Lemmerman's [JPackageScriptFX](https://github.com/dlemmermann/JPackageScriptFX). You can only build an installer for the platform the maven build is running on.
On Windows you need the [Wix Toolset](https://wixtoolset.org) installed on the machine. I had to enable .NET Framework 3.5 (Control Panel - Windows Features - check '.NET Framework 3.5'). Maven will find it, no need to open the program.

It's activated with separate maven build-* profiles:

    mvn -P build-win package
    mvn -P build-mac package  (untested)
    mvn -P build-deb package
    mvn -P build-rpm package (also untested, somehow does not work from debian based distro)
    
In ./target/installer you'll find the .msi/.deb/.rpm/.dkp/.pkg for your platform.


#### GraalVM
Profile the uses gluon's [client-maven-plugin](https://github.com/gluonhq/client-maven-plugin) and [spring-native](https://github.com/spring-projects-experimental/spring-native) (they finally work together!) to generate AOT compiled executable. This doesn't even require a jvm at all anymore.

Download [graalvm 21.0.x](https://github.com/graalvm/graalvm-ce-builds/releases)
Set `GRAALVM_HOME` environment variable similar like setting `JAVA_HOME`
Install additional software required, read [here](https://docs.gluonhq.com/#_platforms) on what's required on which platform.

On ubuntu I have also installed libavcodec-dev libavformat-dev libavutil-dev libasound2-dev to make it work.

On windows you'll need [Visual Studio 2019 Community Edition](https://visualstudio.microsoft.com/downloads) plus specific components.
Maven needs to be started in `x64 Native Tools Command Prompt for VS 2019` NOT just the cmd or "Developer Command Prompt". Make sure it's x64. 

    mvn -P spring-graal client:build
    
In ./target/client/PLATFORM you'll find the executeable.
   
***
#### Run in the browser with jPro (commercial license !)

    mvn -P jpro jpro:release

Extract the zip, go into the /bin folder and run start-script with java11 on the path.
Visit http://localhost:8080


#### Web Launcher with update mechanism

For https://openwebstart.com/

     mvn -P jnlp package
     
Signs all jar's with the example openwebstart.jks and generates a jnlp-file (with a very old webstart-maven-plugin) as a starting point. Remove the line:

    codebase="http://motorbrot.org/404/jnlp"

from ./target/jnlp/OpenJfxJcrBrowser.jnlp. When you have openwebstart installed on your machine you can doubleclick it and it will start. Add a proper codebase + jks and you can put it on a static webserver or shared network folder.

Other notable alternatives:
https://github.com/threerings/getdown
https://github.com/edvin/fxlauncher

***
## ToDo: github actions for win/mac/linux builds

tbc



***
[1] https://netbeans.org/bugzilla/show_bug.cgi?id=253594
